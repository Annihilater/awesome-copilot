---
description: '规范驱动工作流 v1 提供了一种结构化的软件开发方法，确保需求被清晰定义，设计被细致规划，实现被彻底记录和验证。'
applyTo: '**'
---

# 规范驱动工作流 v1

**规范驱动工作流：**
连接需求和实现之间的桥梁。

**始终维护这些工件：**

- **`requirements.md`**：结构化 EARS 记号法中的用户故事和验收标准。
- **`design.md`**：技术架构、时序图、实现考虑。
- **`tasks.md`**：详细的、可跟踪的实现计划。

## 通用文档框架

**文档规则：**
使用详细模板作为所有文档的**主要真实来源**。

**摘要格式：**
仅用于简洁的工件，如变更日志和拉取请求描述。

### 详细文档模板

#### 行动文档模板（所有步骤/执行/测试）

```bash
### [类型] - [行动] - [时间戳]
**目标**：[要完成的目标]
**上下文**：[当前状态、需求和对先前步骤的引用]
**决策**：[选择的方法和理由，如适用则引用决策记录]
**执行**：[采取的步骤、使用的参数和命令。对于代码，包含文件路径。]
**输出**：[完整的未删减结果、日志、命令输出和指标]
**验证**：[成功验证方法和结果。如果失败，包含补救计划。]
**下一步**：[到下一个具体行动的自动继续计划]
```

#### 决策记录模板（所有决策）

```bash
### 决策 - [时间戳]
**决策**：[做出的决定]
**上下文**：[需要决策的情况和驱动它的数据]
**选项**：[评估的替代方案及简要利弊]
**理由**：[为什么选择的选项更优，明确说明权衡]
**影响**：[对实现、可维护性和性能的预期后果]
**审查**：[重新评估此决策的条件或时间表]
```

### 摘要格式（用于报告）

#### 精简行动日志

用于生成简洁变更日志。每个日志条目都来自完整的行动文档。

`[类型][时间戳] 目标：[X] → 行动：[Y] → 结果：[Z] → 下一步：[W]`

#### 压缩决策记录

用于拉取请求摘要或执行摘要。

`决策：[X] | 理由：[Y] | 影响：[Z] | 审查：[日期]`

## 执行工作流（6 阶段循环）

**永远不要跳过任何步骤。使用一致的术语。减少歧义。**

### **阶段 1：分析**

**目标：**

- 理解问题。
- 分析现有系统。
- 产生清晰、可测试的需求集。
- 思考可能的解决方案及其影响。

**检查清单：**

- [ ] 阅读所有提供的代码、文档、测试和日志。
      - 记录文件清单、摘要和初始分析结果。
- [ ] 用 **EARS 记号法** 定义需求：
      - 将功能请求转换为结构化、可测试的需求。
      - 格式：`当 [条件或事件] 时，系统应当 [预期行为]`
- [ ] 识别依赖关系和约束。
      - 记录带有风险和缓解策略的依赖图。
- [ ] 映射数据流和交互。
      - 记录系统交互图和数据模型。
- [ ] 编目边缘情况和故障。
      - 记录全面的边缘情况矩阵和潜在故障点。
- [ ] 评估信心。
      - 基于需求清晰度、复杂性和问题范围生成 **信心分数（0-100%）**。
      - 记录分数及其理由。

**关键约束：**

- **在所有需求都清晰并记录之前，不要继续。**

### **阶段 2：设计**

**目标：**

- 创建全面的技术设计和详细的实现计划。

**检查清单：**

- [ ] **基于信心分数定义自适应执行策略：**
  - **高信心（>85%）**
    - 起草全面的、逐步的实现计划。
    - 跳过概念验证步骤。
    - 进行完整的自动化实现。
    - 维护标准的全面文档。
  - **中等信心（66–85%）**
    - 优先考虑 **概念验证（PoC）** 或 **最小可行产品（MVP）**。
    - 为 PoC/MVP 定义明确的成功标准。
    - 首先构建和验证 PoC/MVP，然后逐步扩展计划。
    - 记录 PoC/MVP 目标、执行和验证结果。
  - **低信心（<66%）**
    - 将第一阶段专门用于研究和知识构建。
    - 使用语义搜索并分析类似实现。
    - 将发现综合到研究文档中。
    - 研究后重新运行分析阶段。
    - 如果信心仍然很低，则升级。

- [ ] **在 `design.md` 中记录技术设计：**
  - **架构：** 组件和交互的高级概述。
  - **数据流：** 图表和描述。
  - **接口：** API 合约、模式、面向公众的函数签名。
  - **数据模型：** 数据结构和数据库模式。

- [ ] **记录错误处理：**
  - 创建带有程序和预期响应的错误矩阵。

- [ ] **定义单元测试策略。**

- [ ] **在 `tasks.md` 中创建实现计划：**
  - 对于每个任务，包括描述、预期结果和依赖关系。

**关键约束：**

- **在设计和计划完成并验证之前，不要进入实现阶段。**

### **阶段 3：实现**

**目标：**

- 根据设计和计划编写生产质量代码。

**检查清单：**

- [ ] 以小的、可测试的增量编写代码。
      - 记录每个增量的代码更改、结果和测试链接。
- [ ] 从依赖关系向上实现。
      - 记录解决顺序、理由和验证。
- [ ] 遵循约定。
      - 记录遵守情况和任何偏差，并使用决策记录。
- [ ] 添加有意义的注释。
      - 专注于意图（"为什么"），而不是机制（"什么"）。
- [ ] 按计划创建文件。
      - 记录文件创建日志。
- [ ] 实时更新任务状态。

**关键约束：**

- **在所有实现步骤都记录和测试之前，不要合并或部署代码。**

### **阶段 4：验证**

**目标：**

- 验证实现满足所有需求和质量标准。

**检查清单：**

- [ ] 执行自动化测试。
      - 记录输出、日志和覆盖率报告。
      - 对于失败，记录根本原因分析和补救。
- [ ] 如有必要，执行手动验证。
      - 记录程序、检查清单和结果。
- [ ] 测试边缘情况和错误。
      - 记录结果和正确错误处理的证据。
- [ ] 验证性能。
      - 记录指标和分析关键部分。
- [ ] 记录执行跟踪。
      - 记录路径分析和运行时行为。

**关键约束：**

- **在所有验证步骤完成且所有问题解决之前，不要继续。**

### **阶段 5：反思**

**目标：**

- 改进代码库，更新文档，分析性能。

**检查清单：**

- [ ] 为可维护性重构。
      - 记录决策、前后比较和影响。
- [ ] 更新所有项目文档。
      - 确保所有 README、图表和注释都是最新的。
- [ ] 识别潜在改进。
      - 记录带有优先级的待办事项。
- [ ] 验证成功标准。
      - 记录最终验证矩阵。
- [ ] 执行元分析。
      - 反思效率、工具使用和协议遵守。
- [ ] 自动创建技术债务问题。
      - 记录清单和补救计划。

**关键约束：**

- **在所有文档和改进行动都记录之前，不要关闭阶段。**

### **阶段 6：交接**

**目标：**

- 为审查和部署打包工作，并过渡到下一个任务。

**检查清单：**

- [ ] 生成执行摘要。
      - 使用 **压缩决策记录** 格式。
- [ ] 准备拉取请求（如适用）：
    1. 执行摘要。
    2. 来自 **精简行动日志** 的变更日志。
    3. 验证工件和决策记录的链接。
    4. 最终 `requirements.md`、`design.md` 和 `tasks.md` 的链接。
- [ ] 完成工作空间。
      - 将中间文件、日志和临时工件存档到 `.agent_work/`。
- [ ] 继续下一个任务。
      - 记录过渡或完成。

**关键约束：**

- **在所有交接步骤完成并记录之前，不要认为任务完成。**

## 故障排除和重试协议

**如果遇到错误、歧义或阻塞：**

**检查清单：**

1. **重新分析**：
   - 重新访问分析阶段。
   - 确认所有需求和约束都清晰完整。
2. **重新设计**：
   - 重新访问设计阶段。
   - 根据需要更新技术设计、计划或依赖关系。
3. **重新规划**：
   - 调整 `tasks.md` 中的实现计划以解决新发现。
4. **重试执行**：
   - 使用修正的参数或逻辑重新执行失败的步骤。
5. **升级**：
   - 如果重试后问题仍然存在，请遵循升级协议。

**关键约束：**

- **永远不要在未解决的错误或歧义的情况下继续。始终记录故障排除步骤和结果。**

## 技术债务管理（自动化）

### 识别和记录

- **代码质量**：在实现过程中使用静态分析持续评估代码质量。
- **捷径**：明确记录所有速度优于质量的决策及其后果在决策记录中。
- **工作空间**：监控组织偏移和命名不一致。
- **文档**：跟踪不完整、过时或缺失的文档。

### 自动问题创建模板

```text
**标题**：[技术债务] - [简要描述]
**优先级**：[基于业务影响和补救成本的高/中/低]
**位置**：[文件路径和行号]
**原因**：[为什么产生债务，如有可用则链接到决策记录]
**影响**：[当前和未来后果（例如，减慢开发，增加错误风险）]
**补救**：[具体、可操作的解决步骤]
**工作量**：[解决工作量估计（例如，T恤尺寸：S、M、L）]
```

### 补救（自动优先级）

- 基于风险的优先级和依赖分析。
- 工作量估计以帮助未来规划。
- 为大型重构工作提出迁移策略。

## 质量保证（自动化）

### 持续监控

- **静态分析**：代码风格、质量、安全漏洞和架构规则遵守的检查。
- **动态分析**：在暂存环境中监控运行时行为和性能。
- **文档**：文档完整性和准确性的自动检查（例如，链接、格式）。

### 质量指标（自动跟踪）

- 代码覆盖率百分比和差距分析。
- 每个函数/方法的圈复杂度分数。
- 可维护性指数评估。
- 技术债务比率（例如，估计补救时间与开发时间）。
- 文档覆盖率百分比（例如，带注释的公共方法）。

## EARS 记号法参考

**EARS（需求语法简化方法）** - 需求的标准格式：

- **普遍性**：`系统应当 [预期行为]`
- **事件驱动**：`当 [触发事件] 时，系统应当 [预期行为]`
- **状态驱动**：`在 [特定状态] 时，系统应当 [预期行为]`
- **不希望的行为**：`如果 [不希望的条件]，那么系统应当 [所需响应]`
- **可选**：`在 [包含功能] 的地方，系统应当 [预期行为]`
- **复杂**：上述模式的组合，用于复杂需求

每个需求必须是：

- **可测试的**：可以通过自动化或手动测试验证
- **明确的**：只能有一种解释
- **必要的**：对系统目的有贡献
- **可行的**：可以在约束内实现
- **可追踪的**：与用户需求和设计元素相链接