---
description: '编写遵循惯用 Go 实践和社区标准的 Go 代码指南'
applyTo: '**/*.go,**/go.mod,**/go.sum'
---

# Go 开发指南

编写 Go 代码时遵循惯用 Go 实践和社区标准。这些指南基于 [Effective Go](https://go.dev/doc/effective_go)、[Go Code Review Comments](https://go.dev/wiki/CodeReviewComments) 和 [Google's Go Style Guide](https://google.github.io/styleguide/go/)。

## 通用指南

- 编写简单、清晰、惯用的 Go 代码
- 优先考虑清晰性和简单性而非聪明性
- 遵循最少惊讶原则
- 保持快乐路径左对齐（最小化缩进）
- 提前返回以减少嵌套
- 使零值有用
- 为导出的类型、函数、方法和包编写文档
- 使用 Go modules 进行依赖管理

## 命名约定

### 包 (Packages)

- 使用小写、单个单词的包名
- 避免下划线、连字符或 mixedCaps
- 选择描述包提供什么而不是包含什么的名称
- 避免通用名称如 `util`、`common` 或 `base`
- 包名应该是单数，而非复数

### 变量和函数

- 使用 mixedCaps 或 MixedCaps（驼峰命名）而不是下划线
- 保持名称简短但具有描述性
- 仅在非常短的作用域中使用单字母变量（如循环索引）
- 导出的名称以大写字母开头
- 未导出的名称以小写字母开头
- 避免口吃（例如，避免 `http.HTTPServer`，优先使用 `http.Server`）

### 接口 (Interfaces)

- 在可能的情况下使用 -er 后缀命名接口（例如 `Reader`、`Writer`、`Formatter`）
- 单方法接口应该以方法名命名（例如 `Read` → `Reader`）
- 保持接口小巧且专注

### 常量 (Constants)

- 导出的常量使用 MixedCaps
- 未导出的常量使用 mixedCaps
- 使用 `const` 块对相关常量进行分组
- 考虑使用类型化常量以获得更好的类型安全性

## 代码风格和格式化

### 格式化

- 始终使用 `gofmt` 格式化代码
- 使用 `goimports` 自动管理导入
- 保持合理的行长度（无硬性限制，但考虑可读性）
- 添加空行分隔逻辑代码组

### 注释

- 用完整句子编写注释
- 以被描述事物的名称开始句子
- 包注释应以 "Package [name]" 开头
- 大多数注释使用行注释（`//`）
- 谨慎使用块注释（`/* */`），主要用于包文档
- 记录为什么，而不是什么，除非什么是复杂的

### 错误处理

- 在函数调用后立即检查错误
- 除非有充分理由，否则不要使用 `_` 忽略错误（记录原因）
- 使用 `fmt.Errorf` 和 `%w` 动词包装错误并添加上下文
- 当需要检查特定错误时创建自定义错误类型
- 将错误返回作为最后一个返回值
- 将错误变量命名为 `err`
- 保持错误消息小写且不以标点符号结尾

## 架构和项目结构

### 包组织

- 遵循标准 Go 项目布局约定
- 将 `main` 包保留在 `cmd/` 目录中
- 将可重用包放在 `pkg/` 或 `internal/` 中
- 对不应被外部项目导入的包使用 `internal/`
- 将相关功能分组到包中
- 避免循环依赖

### 依赖管理

- 使用 Go modules（`go.mod` 和 `go.sum`）
- 保持依赖最小化
- 定期更新依赖以获得安全补丁
- 使用 `go mod tidy` 清理未使用的依赖
- 只在必要时 vendor 依赖

## 类型安全和语言特性

### 类型定义

- 定义类型以增加意义和类型安全性
- 为 JSON、XML、数据库映射使用结构标签
- 优先使用显式类型转换
- 谨慎使用类型断言并检查第二个返回值

### 指针 vs 值

- 对大型结构或需要修改接收器时使用指针
- 对小型结构和需要不可变性时使用值
- 在类型的方法集内保持一致
- 选择指针 vs 值接收器时考虑零值

### 接口和组合

- 接受接口，返回具体类型
- 保持接口小巧（1-3 个方法是理想的）
- 使用嵌入进行组合
- 在接口使用的地方附近定义接口，而不是在实现的地方
- 除非必要，否则不要导出接口

## 并发

### Goroutines

- 不要在库中创建 goroutines；让调用者控制并发
- 始终知道 goroutine 如何退出
- 使用 `sync.WaitGroup` 或 channels 等待 goroutines
- 通过确保清理避免 goroutine 泄露

### Channels

- 使用 channels 在 goroutines 之间通信
- 不要通过共享内存进行通信；通过通信共享内存
- 从发送方关闭 channels，而不是接收方
- 当知道容量时使用缓冲 channels
- 对非阻塞操作使用 `select`

### 同步

- 使用 `sync.Mutex` 保护共享状态
- 保持临界区小
- 当有许多读者时使用 `sync.RWMutex`
- 在可能时优先使用 channels 而不是 mutexes
- 对一次性初始化使用 `sync.Once`

## 错误处理模式

### 创建错误

- 对简单静态错误使用 `errors.New`
- 对动态错误使用 `fmt.Errorf`
- 为特定领域错误创建自定义错误类型
- 为哨兵错误导出错误变量
- 使用 `errors.Is` 和 `errors.As` 进行错误检查

### 错误传播

- 在向上传播错误时添加上下文
- 不要记录并返回错误（选择其一）
- 在适当的级别处理错误
- 考虑使用结构化错误以便更好地调试

## API 设计

### HTTP Handlers

- 对简单处理器使用 `http.HandlerFunc`
- 对需要状态的处理器实现 `http.Handler`
- 对横切关注点使用中间件
- 设置适当的状态码和头部
- 优雅地处理错误并返回适当的错误响应

### JSON APIs

- 使用结构标签控制 JSON 编组
- 验证输入数据
- 对可选字段使用指针
- 考虑对延迟解析使用 `json.RawMessage`
- 适当处理 JSON 错误

## 性能优化

### 内存管理

- 在热路径中最小化分配
- 在可能时重用对象（考虑 `sync.Pool`）
- 对小型结构使用值接收器
- 当大小已知时预分配切片
- 避免不必要的字符串转换

### 性能分析

- 使用内置性能分析工具（`pprof`）
- 基准测试关键代码路径
- 在优化前进行性能分析
- 首先专注于算法改进
- 考虑使用 `testing.B` 进行基准测试

## 测试

### 测试组织

- 将测试保留在同一包中（白盒测试）
- 对黑盒测试使用 `_test` 包后缀
- 用 `_test.go` 后缀命名测试文件
- 将测试文件放在被测试代码旁边

### 编写测试

- 对多个测试用例使用表驱动测试
- 使用 `Test_functionName_scenario` 描述性地命名测试
- 使用 `t.Run` 的子测试获得更好的组织
- 测试成功和错误情况
- 谨慎使用 `testify` 或类似库

### 测试辅助函数

- 用 `t.Helper()` 标记辅助函数
- 为复杂设置创建测试夹具
- 对测试和基准测试中使用的函数使用 `testing.TB` 接口
- 使用 `t.Cleanup()` 清理资源

## 安全最佳实践

### 输入验证

- 验证所有外部输入
- 使用强类型防止无效状态
- 在 SQL 查询中使用前清理数据
- 小心处理来自用户输入的文件路径
- 为不同上下文验证和转义数据（HTML、SQL、shell）

### 密码学

- 使用标准库加密包
- 不要实现自己的密码学
- 使用 crypto/rand 生成随机数
- 使用 bcrypt 或类似方法存储密码
- 对网络通信使用 TLS

## 文档

### 代码文档

- 为所有导出的符号编写文档
- 以符号名称开始文档
- 在有帮助时在文档中使用示例
- 保持文档接近代码
- 代码更改时更新文档

### README 和文档文件

- 包含清晰的设置说明
- 记录依赖和要求
- 提供使用示例
- 记录配置选项
- 包含故障排除部分

## 工具和开发工作流

### 必备工具

- `go fmt`：格式化代码
- `go vet`：查找可疑构造
- `golint` 或 `golangci-lint`：额外的代码检查
- `go test`：运行测试
- `go mod`：管理依赖
- `go generate`：代码生成

### 开发实践

- 提交前运行测试
- 使用预提交钩子进行格式化和代码检查
- 保持提交专注和原子性
- 编写有意义的提交消息
- 提交前审查差异

## 要避免的常见陷阱

- 不检查错误
- 忽略竞争条件
- 创建 goroutine 泄露
- 不使用 defer 进行清理
- 并发修改 maps
- 不理解 nil 接口 vs nil 指针
- 忘记关闭资源（文件、连接）
- 不必要地使用全局变量
- 过度使用空接口（`interface{}`）
- 不考虑类型的零值