---
description: '遵循官方建议编写 Dart 和 Flutter 代码的指令。'
applyTo: '**/*.dart'
---

# Dart 和 Flutter

Dart 和 Flutter 团队推荐的最佳实践。这些指令来自 [Effective Dart](https://dart.dev/effective-dart) 和 [架构建议](https://docs.flutter.dev/app-architecture/recommendations)。

## Effective Dart

在过去几年中，我们编写了大量的 Dart 代码，并学到了很多关于什么有效、什么无效的经验。我们与您分享这些，以便您也能编写一致、健壮、快速的代码。有两个总体主题：

1.  **保持一致。** 在格式化和大小写等方面，关于哪个更好的争论是主观的，无法解决。我们所知道的是，保持*一致*客观上是有帮助的。

    如果两段代码看起来不同，应该是因为它们在某种有意义的方式上*确实*不同。当一段代码突出并引起您的注意时，应该是出于有用的原因。

2.  **保持简洁。** Dart 被设计为熟悉的，因此它继承了与 C、Java、JavaScript 和其他语言相同的许多语句和表达式。但我们创建 Dart 是因为这些语言提供的内容有很大的改进空间。我们添加了一堆功能，从字符串插值到初始化形式参数，帮助您更简单、更容易地表达您的意图。

    如果有多种表达方式，您通常应该选择最简洁的一种。这并不是说您应该`代码高尔夫`自己，把整个程序塞进一行。目标是*经济*的代码，而不是*密集*的代码。

### 主题

我们将指南分为几个独立的主题以便于消化：

*   **风格** – 这定义了代码布局和组织的规则，或者至少是 `dart format` 不为您处理的部分。风格主题还指定了如何格式化标识符：`camelCase`、`using_underscores` 等。

*   **文档** – 这告诉您关于注释内容需要知道的一切。包括文档注释和常规的日常代码注释。

*   **用法** – 这教您如何最好地利用语言功能来实现行为。如果它在语句或表达式中，这里会涵盖。

*   **设计** – 这是最软的主题，但范围最广。它涵盖了我们在为库设计一致、可用的 API 方面学到的知识。如果它在类型签名或声明中，这里会讨论。

### 如何阅读主题

每个主题分为几个部分。部分包含指南列表。每个指南以以下词之一开始：

*   **DO** 指南描述应该始终遵循的实践。几乎永远不会有偏离它们的有效理由。

*   **DON'T** 指南是相反的：几乎从来不是好主意的事情。希望我们没有像其他语言那样有那么多这样的指南，因为我们的历史包袱较少。

*   **PREFER** 指南是您*应该*遵循的实践。然而，在某些情况下，做其他事情可能是有意义的。只要确保在这样做时，您理解忽略指南的全部含义。

*   **AVOID** 指南是"prefer"的对偶：您不应该做的事情，但在极少数情况下可能有充分的理由。

*   **CONSIDER** 指南是您可能想要或可能不想要遵循的实践，取决于情况、先例和您自己的偏好。

一些指南描述了规则*不*适用的**例外**。当列出时，例外可能不是详尽的——您可能仍需要在其他情况下使用您的判断。

这听起来像如果您没有正确系鞋带，警察就会破门而入。事情没有那么糟糕。这里的大部分指南都是常识，我们都是有理性的人。目标，一如既往，是好的、可读的和可维护的代码。

### 规则

#### 风格

##### 标识符

*   DO 使用 `UpperCamelCase` 命名类型。
*   DO 使用 `UpperCamelCase` 命名扩展。
*   DO 使用 `lowercase_with_underscores` 命名包、目录和源文件。
*   DO 使用 `lowercase_with_underscores` 命名导入前缀。
*   DO 使用 `lowerCamelCase` 命名其他标识符。
*   PREFER 对常量名使用 `lowerCamelCase`。
*   DO 将超过两个字母的缩写词和缩略词像单词一样大写。
*   PREFER 对未使用的回调参数使用通配符。
*   DON'T 对不是私有的标识符使用前导下划线。
*   DON'T 使用前缀字母。
*   DON'T 显式命名库。

##### 排序

*   DO 将 `dart:` 导入放在其他导入之前。
*   DO 将 `package:` 导入放在相对导入之前。
*   DO 在所有导入之后的单独部分中指定导出。
*   DO 按字母顺序排序各部分。

##### 格式化

*   DO 使用 `dart format` 格式化您的代码。
*   CONSIDER 更改您的代码使其更适合格式化程序。
*   PREFER 80 个字符或更少的行。
*   DO 对所有流控制语句使用大括号。

#### 文档

##### 注释

*   DO 像句子一样格式化注释。
*   DON'T 使用块注释进行文档。

##### 文档注释

*   DO 使用 `///` 文档注释来记录成员和类型。
*   PREFER 为公共 API 编写文档注释。
*   CONSIDER 编写库级文档注释。
*   CONSIDER 为私有 API 编写文档注释。
*   DO 以单句摘要开始文档注释。
*   DO 将文档注释的第一句分离到自己的段落中。
*   AVOID 与周围上下文的冗余。
*   PREFER 如果函数或方法的主要目的是副作用，则以第三人称动词开始注释。
*   PREFER 以名词短语开始非布尔变量或属性注释。
*   PREFER 以"Whether"后跟名词或动名词短语开始布尔变量或属性注释。
*   PREFER 如果返回值是函数或方法的主要目的，则使用名词短语或非命令式动词短语。
*   DON'T 为属性的 getter 和 setter 都编写文档。
*   PREFER 以名词短语开始库或类型注释。
*   CONSIDER 在文档注释中包含代码示例。
*   DO 在文档注释中使用方括号引用作用域内的标识符。
*   DO 使用散文解释参数、返回值和异常。
*   DO 将文档注释放在元数据注解之前。

##### Markdown

*   AVOID 过度使用 markdown。
*   AVOID 使用 HTML 进行格式化。
*   PREFER 使用反引号围栏进行代码块。

##### 写作

*   PREFER 简洁。
*   AVOID 缩写和首字母缩略词，除非它们很明显。
*   PREFER 使用"this"而不是"the"来引用成员的实例。

#### 用法

##### 库

*   DO 在 `part of` 指令中使用字符串。
*   DON'T 导入另一个包的 `src` 目录内的库。
*   DON'T 允许导入路径进入或离开 `lib`。
*   PREFER 相对导入路径。

##### Null

*   DON'T 显式初始化变量为 `null`。
*   DON'T 使用 `null` 的显式默认值。
*   DON'T 在相等操作中使用 `true` 或 `false`。
*   AVOID 如果您需要检查 `late` 变量是否已初始化。
*   CONSIDER 为使用可空类型使用类型提升或 null 检查模式。

##### 字符串

*   DO 使用相邻字符串连接字符串文字。
*   PREFER 使用插值来组合字符串和值。
*   AVOID 在不需要时在插值中使用大括号。

##### 集合

*   DO 在可能时使用集合文字。
*   DON'T 使用 `.length` 检查集合是否为空。
*   AVOID 对函数文字使用 `Iterable.forEach()`。
*   DON'T 使用 `List.from()`，除非您打算更改结果的类型。
*   DO 使用 `whereType()` 按类型过滤集合。
*   DON'T 在附近的操作可以完成时使用 `cast()`。
*   AVOID 使用 `cast()`。

##### 函数

*   DO 使用函数声明将函数绑定到名称。
*   DON'T 在 tear-off 可以完成时创建 lambda。

##### 变量

*   DO 对局部变量遵循 `var` 和 `final` 的一致规则。
*   AVOID 存储您可以计算的内容。

##### 成员

*   DON'T 不必要地在 getter 和 setter 中包装字段。
*   PREFER 使用 `final` 字段制作只读属性。
*   CONSIDER 对简单成员使用 `=>`。
*   DON'T 使用 `this.`，除非重定向到命名构造函数或避免遮蔽。
*   DO 在可能时在声明时初始化字段。

##### 构造函数

*   DO 在可能时使用初始化形式参数。
*   DON'T 在构造函数初始化列表可以完成时使用 `late`。
*   DO 对空构造函数体使用 `;` 而不是 `{}`。
*   DON'T 使用 `new`。
*   DON'T 冗余使用 `const`。

##### 错误处理

*   AVOID 不带 `on` 子句的 catch。
*   DON'T 丢弃不带 `on` 子句的 catch 中的错误。
*   DO 仅对编程错误抛出实现 `Error` 的对象。
*   DON'T 显式捕获 `Error` 或实现它的类型。
*   DO 使用 `rethrow` 重新抛出捕获的异常。

##### 异步

*   PREFER async/await 而不是使用原始 future。
*   DON'T 在没有有用效果时使用 `async`。
*   CONSIDER 使用高阶方法转换流。
*   AVOID 直接使用 Completer。
*   DO 在消除类型参数可能是 `Object` 的 `FutureOr<T>` 时测试 `Future<T>`。

#### 设计

##### 名称

*   DO 一致地使用术语。
*   AVOID 缩写。
*   PREFER 将最具描述性的名词放在最后。
*   CONSIDER 使代码读起来像句子。
*   PREFER 非布尔属性或变量的名词短语。
*   PREFER 布尔属性或变量的非命令式动词短语。
*   CONSIDER 省略命名布尔参数的动词。
*   PREFER 布尔属性或变量的"正面"名称。
*   PREFER 主要目的是副作用的函数或方法的命令式动词短语。
*   PREFER 如果返回值是函数或方法的主要目的，则使用名词短语或非命令式动词短语。
*   CONSIDER 如果您想引起对函数或方法执行的工作的注意，则使用命令式动词短语。
*   AVOID 以 `get` 开始方法名。
*   PREFER 如果方法将对象的状态复制到新对象，则将方法命名为 `to...()`。
*   PREFER 如果方法返回由原始对象支持的不同表示，则将方法命名为 `as...()`。
*   AVOID 在函数或方法名称中描述参数。
*   DO 在命名类型参数时遵循现有的助记约定。

##### 库

*   PREFER 使声明私有。
*   CONSIDER 在同一库中声明多个类。

##### 类和混入

*   AVOID 在简单函数可以完成时定义单成员抽象类。
*   AVOID 定义仅包含静态成员的类。
*   AVOID 扩展不打算被子类化的类。
*   DO 使用类修饰符控制您的类是否可以被扩展。
*   AVOID 实现不打算作为接口的类。
*   DO 使用类修饰符控制您的类是否可以作为接口。
*   PREFER 定义纯 `mixin` 或纯 `class` 而不是 `mixin class`。

##### 构造函数

*   CONSIDER 如果类支持，使您的构造函数为 `const`。

##### 成员

*   PREFER 使字段和顶级变量为 `final`。
*   DO 对概念上访问属性的操作使用 getter。
*   DO 对概念上更改属性的操作使用 setter。
*   DON'T 定义没有相应 getter 的 setter。
*   AVOID 使用运行时类型测试来伪造重载。
*   AVOID 没有初始化器的公共 `late final` 字段。
*   AVOID 返回可空的 `Future`、`Stream` 和集合类型。
*   AVOID 仅为启用流畅接口而从方法返回 `this`。

##### 类型

*   DO 对没有初始化器的变量进行类型注释。
*   DO 如果类型不明显，对字段和顶级变量进行类型注释。
*   DON'T 冗余地对初始化的局部变量进行类型注释。
*   DO 对函数声明的返回类型进行注释。
*   DO 对函数声明的参数类型进行注释。
*   DON'T 对函数表达式的推断参数类型进行注释。
*   DON'T 对初始化形式参数进行类型注释。
*   DO 对未推断的泛型调用编写类型参数。
*   DON'T 对推断的泛型调用编写类型参数。
*   AVOID 编写不完整的泛型类型。
*   DO 用 `dynamic` 注释而不是让推断失败。
*   PREFER 函数类型注释中的签名。
*   DON'T 为 setter 指定返回类型。
*   DON'T 使用传统的 typedef 语法。
*   PREFER 内联函数类型而不是 typedef。
*   PREFER 对参数使用函数类型语法。
*   AVOID 使用 `dynamic`，除非您想禁用静态检查。
*   DO 使用 `Future<void>` 作为不产生值的异步成员的返回类型。
*   AVOID 使用 `FutureOr<T>` 作为返回类型。

##### 参数

*   AVOID 位置布尔参数。
*   AVOID 如果用户可能想要省略较早的参数，则使用可选位置参数。
*   AVOID 接受特殊"无参数"值的强制参数。
*   DO 使用包含起始和排除结束参数来接受范围。

##### 相等性

*   DO 如果您重写 `==`，则重写 `hashCode`。
*   DO 使您的 `==` 操作符遵守相等性的数学规则。
*   AVOID 为可变类定义自定义相等性。
*   DON'T 使 `==` 的参数可空。

---

## Flutter 架构建议

本页面介绍架构最佳实践、为什么它们重要，以及我们是否建议您的 Flutter 应用程序使用它们。您应该将这些建议视为建议，而不是坚定的规则，您应该根据应用程序的独特需求来调整它们。

此页面上的最佳实践有一个优先级，反映了 Flutter 团队推荐它的强烈程度。

* **强烈推荐：** 如果您开始构建新应用程序，您应该始终实现此建议。您应该强烈考虑重构现有应用程序以实现此实践，除非这样做会与您当前的方法根本冲突。
* **推荐**：此实践可能会改善您的应用程序。
* **有条件**：此实践在某些情况下可以改善您的应用程序。

### 关注点分离

您应该将应用程序分为 UI 层和数据层。在这些层内，您应该进一步按职责将逻辑分离到类中。

#### 使用明确定义的数据层和 UI 层。
**强烈推荐**

关注点分离是最重要的架构原则。数据层向应用程序的其余部分公开应用程序数据，并包含应用程序中的大部分业务逻辑。UI 层显示应用程序数据并监听用户的用户事件。UI 层包含 UI 逻辑和小部件的单独类。

#### 在数据层使用存储库模式。
**强烈推荐**

存储库模式是一种软件设计模式，它将数据访问逻辑与应用程序的其余部分隔离。它在应用程序的业务逻辑和底层数据存储机制（数据库、API、文件系统等）之间创建抽象层。实际上，这意味着创建 Repository 类和 Service 类。

#### 在 UI 层使用 ViewModel 和 View。（MVVM）
**强烈推荐**

关注点分离是最重要的架构原则。这种特定的分离使您的代码不那么容易出错，因为您的小部件保持"愚蠢"。

#### 使用 `ChangeNotifier` 和 `Listenable` 处理小部件更新。
**有条件**

> 有许多选项来处理状态管理，最终决定归结为个人偏好。

`ChangeNotifier` API 是 Flutter SDK 的一部分，是让您的小部件观察 ViewModel 中更改的便捷方式。

#### 不要在小部件中放置逻辑。
**强烈推荐**

逻辑应该封装在 ViewModel 上的方法中。视图应该包含的唯一逻辑是：
* 基于 ViewModel 中的标志或可空字段显示和隐藏小部件的简单 if 语句
* 依赖小部件计算的动画逻辑
* 基于设备信息的布局逻辑，如屏幕大小或方向。
* 简单的路由逻辑

#### 使用领域层。
**有条件**

> 在具有复杂逻辑要求的应用程序中使用。

只有当您的应用程序具有超复杂的逻辑拥挤您的 ViewModel，或者您发现自己在 ViewModel 中重复逻辑时，才需要领域层。在非常大的应用程序中，用例是有用的，但在大多数应用程序中，它们会增加不必要的开销。

### 处理数据

小心处理数据使您的代码更容易理解，不那么容易出错，并防止创建格式错误或意外的数据。

#### 使用单向数据流。
**强烈推荐**

数据更新应该只从数据层流向 UI 层。UI 层中的交互被发送到数据层进行处理。

#### 使用 `Command` 处理用户交互事件。
**推荐**

Command 防止应用程序中的渲染错误，并标准化 UI 层向数据层发送事件的方式。

#### 使用不可变数据模型。
**强烈推荐**

不可变数据对于确保任何必要的更改仅在适当的位置（通常是数据层或领域层）发生至关重要。因为不可变对象在创建后无法修改，您必须创建新实例来反映更改。此过程防止 UI 层中的意外更新，并支持清晰的单向数据流。

#### 使用 freezed 或 built_value 生成不可变数据模型。
**推荐**

您可以使用包来帮助在数据模型中生成有用的功能，`freezed` 或 `built_value`。这些可以生成常见的模型方法，如 JSON 序列化/反序列化、深度相等检查和复制方法。如果您有很多模型，这些代码生成包可能会为您的应用程序增加显著的构建时间。

#### 创建单独的 API 模型和领域模型。
**有条件**

> 在大型应用程序中使用。

使用单独的模型会增加冗长性，但防止 ViewModel 和用例中的复杂性。

### 应用程序结构

组织良好的代码既有利于应用程序本身的健康，也有利于处理代码的团队。

#### 使用依赖注入。
**强烈推荐**

依赖注入防止您的应用程序具有全局可访问的对象，这使您的代码不那么容易出错。我们建议您使用 `provider` 包来处理依赖注入。

#### 使用 `go_router` 进行导航。
**推荐**

Go_router 是编写 90% Flutter 应用程序的首选方式。有一些特定的用例 go_router 无法解决，在这种情况下，您可以直接使用 `Flutter Navigator API` 或尝试在 `pub.dev` 上找到的其他包。

#### 对类、文件和目录使用标准化命名约定。
**推荐**

我们建议根据类所代表的架构组件命名类。例如，您可能有以下类：

* HomeViewModel
* HomeScreen
* UserRepository
* ClientApiService

为了清晰起见，我们不建议使用可能与 Flutter SDK 中的对象混淆的名称。例如，您应该将共享小部件放在名为 `ui/core/` 的目录中，而不是名为 `/widgets` 的目录。

#### 使用抽象存储库类
**强烈推荐**

存储库类是应用程序中所有数据的真实来源，并促进与外部 API 的通信。创建抽象存储库类允许您创建不同的实现，可用于不同的应用程序环境，如"开发"和"暂存"。

### 测试

良好的测试实践使您的应用程序灵活。它还使添加新逻辑和新 UI 变得简单和低风险。

#### 分别和一起测试架构组件。
**强烈推荐**

* 为每个服务、存储库和 ViewModel 类编写单元测试。这些测试应该单独测试每个方法的逻辑。
* 为视图编写小部件测试。测试路由和依赖注入特别重要。

#### 为测试制作假对象（并编写利用假对象的代码。）
**强烈推荐**

假对象不像关心任何给定方法的内部工作那样关心输入和输出。如果您在编写应用程序代码时牢记这一点，您将被迫编写具有明确定义输入和输出的模块化、轻量级函数和类。