---
description: '生成现代 Azure Terraform 代码的指南'
applyTo: '**/*.tf'
---

## 1. 使用最新的 Terraform 和 Provider

始终针对最新的稳定版 Terraform 和 Azure provider。在代码中，指定所需的 Terraform 和 provider 版本以强制执行此操作。保持 provider 版本更新以获得新功能和修复。

## 2. 整洁地组织代码

使用逻辑文件分离来构建 Terraform 配置：

- 使用 `main.tf` 存放资源
- 使用 `variables.tf` 存放输入变量
- 使用 `outputs.tf` 存放输出
- 遵循一致的命名约定和格式化（`terraform fmt`）

这使代码易于导航和维护。

## 3. 封装为模块

使用 Terraform 模块来组织可重用的基础设施组件。对于任何将在多个上下文中使用的资源集：

- 创建一个具有自己变量/输出的模块
- 引用它而不是重复代码
- 这促进了重用和一致性

## 4. 利用变量和输出

- **参数化**所有可配置的值，使用具有类型和描述的变量
- 在适当的地方为可选变量**提供默认值**
- **使用输出**来公开关键资源属性，供其他模块或用户参考
- **相应地标记敏感值**以保护秘密

## 5. Provider 选择（AzureRM vs AzAPI）

- **大多数场景使用 `azurerm` provider** – 它提供高稳定性并覆盖大多数 Azure 服务
- **仅在以下情况下使用 `azapi` provider**：
  - 需要最新的 Azure 功能
  - `azurerm` 尚不支持的资源
- **在代码注释中记录选择**
- 两个 provider 可以在需要时一起使用，但在有疑问时优先选择 `azurerm`

## 6. 最小依赖

- **不要引入**超出项目范围的额外 provider 或模块，除非得到确认
- 如果需要特殊的 provider（例如 `random`、`tls`）或外部模块：
  - 添加注释解释
  - 确保用户批准
- 保持基础设施堆栈精简，避免不必要的复杂性

## 7. 确保幂等性

- 编写可以重复应用并获得相同结果的配置
- **避免非幂等操作**：
  - 每次应用时运行的脚本
  - 可能在创建两次时冲突的资源
- **通过多次运行 `terraform apply` 进行测试**，确保第二次运行的结果是零更改
- 使用资源生命周期设置或条件表达式来优雅地处理漂移或外部更改

## 8. 状态管理

- **使用远程后端**（如带有状态锁定的 Azure Storage）安全地存储 Terraform 状态
- 启用团队协作
- **永远不要提交状态文件**到源代码控制
- 这可以防止冲突并保持基础设施状态一致

## 9. 文档和图表

- **维护最新的文档**
- 每当代码更改时，**更新 README.md**，包含任何新的变量、输出或使用说明
- 考虑使用 `terraform-docs` 等工具进行自动化
- 在每次重大更新后**更新架构图**以反映基础设施更改
- 良好的文档和图表确保整个团队了解基础设施

## 10. 验证和测试更改

- 在应用更改之前**运行 `terraform validate`** 并查看 `terraform plan` 输出
- 尽早发现错误或意外修改
- **考虑实施自动检查**：
  - CI 管道
  - 预提交钩子
  - 强制执行格式化、linting 和基本验证